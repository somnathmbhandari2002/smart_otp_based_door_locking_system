from fastapi import FastAPI, HTTPException
from fastapi_mail import FastMail, MessageSchema, ConnectionConfig
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from pymongo import MongoClient
from datetime import datetime, timedelta
import os
from dotenv import load_dotenv

load_dotenv()

app = FastAPI(title="Smart Door OTP System")

# Add CORS middleware - THIS IS CRITICAL FOR ARDUINO CONNECTION----
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allows all origins
    allow_credentials=True,
    allow_methods=["*"],   # Allows all methods
    allow_headers=["*"],   # Allows all headers
)

# Email config from .env----
conf = ConnectionConfig(
    MAIL_USERNAME=os.getenv("MAIL_USERNAME"),
    MAIL_PASSWORD=os.getenv("MAIL_PASSWORD"),
    MAIL_FROM=os.getenv("MAIL_FROM"),
    MAIL_PORT=int(os.getenv("MAIL_PORT", 587)),
    MAIL_SERVER=os.getenv("MAIL_SERVER"),
    MAIL_STARTTLS=True,
    MAIL_SSL_TLS=False,
    USE_CREDENTIALS=True,
    VALIDATE_CERTS=True
)

# MongoDB connection----
mongo_client = MongoClient(os.getenv("MONGO_URL", "mongodb://localhost:27017"))
db = mongo_client["smart_door"]
otp_collection = db["otp"]

print("‚úÖ Database connected successfully")

# Models
class SendOTP(BaseModel):
    otp: str
    mode: str   # lock or unlock

class VerifyOTP(BaseModel):
    otp: str

def get_recipients_list():
    """Get email recipients from environment variable"""
    env = os.getenv("RECIPIENTS")
    if env:
        return [e.strip() for e in env.split(",") if e.strip()]
    return ["example@gmail.com", "example@gmail.com"]

@app.post("/send-otp")
async def send_otp(data: SendOTP):
    """Send OTP to email recipients"""
    print(f"üì® Received OTP request: {data.otp} for {data.mode}")
    
    # Clear previous OTPs
    delete_result = otp_collection.delete_many({})
    print(f"üóëÔ∏è Cleared {delete_result.deleted_count} previous OTPs")

    # Create OTP entry with expiration
    otp_entry = {
        "otp": data.otp,
        "mode": data.mode,
        "created_at": datetime.utcnow(),
        "expire_at": datetime.utcnow() + timedelta(minutes=2)
    }
    otp_collection.insert_one(otp_entry)
    print(f"üíæ OTP saved to database: {data.otp}")

    # Send email
    recipients = get_recipients_list()
    body_html = f"""
    <html>
        <body style="font-family: Arial, sans-serif; padding: 20px;">
            <h2 style="color: #333;">üîê Smart Door OTP</h2>
            <div style="background: #f5f5f5; padding: 15px; border-radius: 5px;">
                <p><strong>OTP Code:</strong> <span style="font-size: 24px; color: #e74c3c;">{data.otp}</span></p>
                <p><strong>Purpose:</strong> {data.mode.upper()} the door</p>
                <p><strong>Expires:</strong> 2 minutes from now</p>
            </div>
            <p style="color: #666; margin-top: 20px;">
                This OTP was generated by your Smart Door Lock System.
            </p>
        </body>
    </html>
    """
    
    try:
        message = MessageSchema(
            subject=f"üîê Your Smart Door OTP for {data.mode.upper()}",
            recipients=recipients,
            body=body_html,
            subtype="html"
        )
        fm = FastMail(conf)
        await fm.send_message(message)
        print(f"‚úÖ OTP email sent successfully to {recipients}")
        
        return {
            "status": "success",
            "message": "OTP sent successfully",
            "recipients": recipients,
            "mode": data.mode
        }
        
    except Exception as e:
        print(f"‚ùå Error sending email: {e}")
        # Still return success for OTP storage, but indicate email failure
        return {
            "status": "partial_success",
            "message": f"OTP stored but email failed: {str(e)}",
            "recipients": recipients,
            "mode": data.mode
        }

@app.post("/verify-otp")
def verify_otp(data: VerifyOTP):
    """Verify OTP from Arduino"""
    print(f"üîç Verifying OTP: {data.otp}")
    
    # Find OTP in database
    record = otp_collection.find_one({"otp": data.otp})
    if not record:
        print(f"‚ùå OTP not found: {data.otp}")
        raise HTTPException(status_code=400, detail="Invalid OTP")
    
    # Check expiration
    if record["expire_at"] < datetime.utcnow():
        otp_collection.delete_one({"otp": data.otp})
        print(f"‚è∞ OTP expired: {data.otp}")
        raise HTTPException(status_code=400, detail="OTP expired")
    
    # Success - get mode and delete OTP
    mode = record["mode"]
    otp_collection.delete_one({"otp": data.otp})
    print(f"‚úÖ OTP verified successfully for mode: {mode}")
    
    return {
        "status": "success",
        "message": "OTP verified successfully",
        "mode": mode
    }

@app.get("/")
def home():
    """Root endpoint"""
    return {
        "message": "Smart Door Backend Running",
        "timestamp": datetime.utcnow().isoformat(),
        "endpoints": {
            "send_otp": "POST /send-otp",
            "verify_otp": "POST /verify-otp",
            "health": "GET /health"
        }
    }

@app.get("/health")
def health_check():
    """Health check endpoint for testing connectivity"""
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "database": "connected" if mongo_client.admin.command('ping') else "disconnected"
    }

if __name__ == "__main__":
    import uvicorn
    print("üöÄ Starting Smart Door OTP Server...")
    uvicorn.run(
        "main:app",
        host="0.0.0.0",  # Important: listen on all interfaces
        port=8000,
        reload=True
    )
